#!/usr/bin/env python3
import argparse
import time
import httpx

HOP_BY_HOP_HEADERS = {
    'Connection', 'Keep-Alive', 'Proxy-Authenticate', 'Proxy-Authorization',
    'TE', 'Trailers', 'Transfer-Encoding', 'Upgrade'
}

def parse_raw_request(file_path, default_scheme):
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
        raw = f.read()
    # Split headers and body
    if '\r\n\r\n' in raw:
        header_part, body = raw.split('\r\n\r\n', 1)
    elif '\n\n' in raw:
        header_part, body = raw.split('\n\n', 1)
    else:
        header_part = raw
        body = ''
    lines = header_part.splitlines()
    # First line: METHOD [URL or path] HTTP/1.1
    request_line = lines[0]
    try:
        method, path, _ = request_line.split(' ', 2)
    except ValueError:
        raise ValueError(f"Invalid request line: {request_line}")
    # Parse headers
    headers = {}
    for line in lines[1:]:
        if ':' in line:
            key, value = line.split(':', 1)
            headers[key.strip()] = value.strip()
    # Remove hop-by-hop and content-length headers
    headers = {k: v for k, v in headers.items()
               if k not in HOP_BY_HOP_HEADERS and k.lower() != 'content-length'}
    # Build URL
    if path.lower().startswith('http://') or path.lower().startswith('https://'):
        url = path
    else:
        host = headers.get('Host')
        if not host:
            raise ValueError("Host header is missing, cannot build URL")
        url = f"{default_scheme}://{host}{path}"
    return method, url, headers, body


def main():
    parser = argparse.ArgumentParser(
        description="Send a raw HTTP request from a file at a given rate (RPM) via HTTP/2 proxy"
    )
    parser.add_argument(
        "file", help="Path to the file with the raw HTTP request (paste from Burp Repeater)"
    )
    parser.add_argument(
        "--rpm", type=int, default=10000,
        help="Requests per minute (default: 10000)"
    )
    parser.add_argument(
        "--count", type=int, default=10000,
        help="Total number of requests to send (default: 10000)"
    )
    parser.add_argument(
        "--scheme", choices=["http", "https"], default="https",
        help="Default URL scheme if path is relative (default: https)"
    )
    args = parser.parse_args()

    interval = 60.0 / args.rpm
    try:
        method, url, headers, body = parse_raw_request(args.file, args.scheme)
    except Exception as e:
        print(f"Error parsing request file: {e}")
        return

    proxies = {
        "http://": "http://localhost:8080",
        "https://": "http://localhost:8080"
    }
    client = httpx.Client(http2=True, proxies=proxies)
    print(
        f"Sending {method} requests to {url} at {args.rpm} RPM "
        f"through proxy localhost:8080 using HTTP/2 (interval {interval:.4f}s)"
    )
    sent = 0
    try:
        while True:
            if args.count and sent >= args.count:
                print(f"Sent {sent} requests, done.")
                break
            try:
                resp = client.request(method, url, headers=headers, content=body)
                sent += 1
                print(f"[{sent}] {resp.status_code}")
            except Exception as e:
                print(f"[{sent+1}] Error: {e}")
            time.sleep(interval)
    except KeyboardInterrupt:
        print(f"\nInterrupted by user. Total sent: {sent}")
    finally:
        client.close()

if __name__ == "__main__":
    main()
